#!/usr/local/bin/node
const options = require(process.env.PWD+"/COMMONMODULES/config.js").get("mySqlConnectionOptions");
const async = require("async");
const mysql = require("mysql");


/*dbcon.query = function query(str,cb){
  console.log(str);
  cb("code","res");
}*/
var raw = require("fs").readFileSync(process.env.PWD+"/ctables.json","utf8").replace(/[\n\r]/g,"");
while(/(\s\s)/g.test(raw)){
  raw = raw.replace(/(\s\s)/g," ");
}
var json = JSON.parse(raw);
var args = JSON.parse(JSON.stringify(process.argv));
args.splice(0,4);
if(process.argv[2]=="--help"||process.argv[2]==null||process.argv[3]==null){
  printUsage();
}else{
  var dbcon = mysql.createConnection({host:options.host,user:process.argv[2],password:process.argv[3]});
  dbcon.query("",function(err,res){
    if(err){
      if(err.code=="ER_ACCESS_DENIED_ERROR"){
        console.log("wrong credentials");
        dbcon.end(process.exit);
      }else if(err.code=="ER_EMPTY_QUERY"){
        execute(parseCommands(args));
      }else{
        console.error(err);
        dbcon.end(process.exit);
      }
    }
  });
}

var existing = {};

function remove(callback){
  var ret = {};
  for(i in existing){
    if(i != "tables"){
      if(i = "database"){
        ret[Object.keys(ret).length] = database;
        ret[Object.keys(ret).length] = tables;
      }else{
        ret[Object.keys(ret).length] = existing[i];
      }
    }else{
      ret[Object.keys(ret).length] = database;
      ret[Object.keys(ret).length] = tables;
    }
  }
  var temp = [];
  console.log(ret);
  for(a in ret){
    for(b in temp){
      if(ret[a]==temp[b]){
        delete ret[a];
      }
    }
    if(ret[a]!=null) temp.push(ret[a]);
  }
  console.log(ret);
  var removed = [];
  async.eachSeries(existing,function(rem, cb){
    console.log("removing: "+rem.toString().split("(")[0].split(" ")[1]);
    switch(rem.toString().split("(")[0].split(" ")[1]){
      case "user":
        dbcon.query(replaceTags(json.drop.user),function(err,res){
          if(err){
            console.error(err);;
          }else{
            removed[removed.length] = rem.toString().split("(")[0].split(" ")[1];
          }
          cb();
        });
        break;
      case "database":
        dbcon.query(replaceTags(json.drop.database),function(err,res){
          if(err){
            console.error(err);;
          }else{
            removed[removed.length] = rem.toString().split("(")[0].split(" ")[1];
          }
          cb();
        });
        break;
      case "tables":
        async.eachSeries(json.drop.tables,function(table){
          dbcon.query(replaceTags(table),function(err,res){
            if(err){
              if(err.code!="ER_NO_DB_ERROR"){
                console.error(err);;
              }
            }else{
              removed[removed.length] = rem.toString().split("(")[0].split(" ")[1];
            }
            cb();
          });
        },cb);
        break;
      default:
        console.log("error, unknown function");
        cb();
    }
  },function(){
    console.log("removed: ",removed);
    existing={};
    if(typeof callback === "function") callback(ret);
  });
}
function parseCommands(commands){
  var creates = {};
  for(command of commands){
    var key = Object.keys(creates).length;
    switch(command){
      case "all":
        creates = {0:database,1:tables,2:user,3:grant};
        break;
      case "database":
        creates[0] = database;
        break;
      case "tables":
        creates[1] = tables;
        break;
      case "user":
        creates[2] = user;
        break;
      case "grant":
        creates[3] = grant;
        break;
      default:
        printUsage();
    }
  }
  return creates;
}
function execute(creates){
  if(Object.keys(creates).length>0){
    async.eachSeries(creates,function(funct,cb){
      funct(cb);
    },function(){
      if(Object.keys(existing).length>0){
        console.log("the following could not be created, because they already existed:");
        for(k in existing){
          console.log(k);
        }
        console.log("overwrite the existing?\n!!!THIS WILL REMOVE ALL OF THEIR CONTENTS!!! (Y/n)");
        process.stdin.on("data",function(data){
          var datastr = data.toString().replace(/[\n\r]/g,"");
          if(datastr == "Y"||datastr =="y"){
            remove(execute);
          }else if(datastr == "N"||datastr == "n"){
            dbcon.end(process.exit);
          }
        })
      }else{
        dbcon.end(process.exit);
      }
    });
  }else{
    printUsage();
  }
}
function database(callback){
  dbcon.query(replaceTags(json.create.database),function(err,res){
    handelResErr(res,err, "successfully created database "+mysql.escape(options.database),database);
    dbcon.query("USE "+options.database+";",function(err,res){
      handelResErr(res,err, "now using database "+mysql.escape(options.database));
      if(typeof callback === "function") callback();
    });
  });
}
function tables(callback){
  async.eachSeries(json.create.tables,function(table,cb){
    dbcon.query(replaceTags(table),function(err,res){
      handelResErr(res,err,"successfully created table "+mysql.escape(table.split(" ")[2].replace(/`/g,"")),tables);
      cb();
    });
  },function(){
    if(typeof callback === "function") callback();
  });
}
function user(callback){
  dbcon.query(replaceTags(json.create.user),function(err,res){
    handelResErr(res,err,"successfully created user "+mysql.escape(options.user),user);
    if(typeof callback === "function") callback();
  });
}
function grant(callback){
  dbcon.query(replaceTags(json.grant),function(err,res){
    handelResErr(res,err,"successfully granted rights for database "+mysql.escape(options.database)+" to user "+mysql.escape(options.user),grant);
    if(typeof callback === "function") callback();
  });
}
function replaceTags(str){
  var a = str.split(">");
  var tags = {};
  for(i in a){
    if(a[i].split("<").length == 2) tags[a[i].split("<")[1]] = (options[a[i].split("<")[1]]);
  }
  for(i in tags){
    if(i=="password"){
      str = str.replace(new RegExp("<"+i+">","g"),mysql.escape(tags[i]));
    }else{
      str = str.replace(new RegExp("<"+i+">","g"),tags[i]);
    }
  }
  return(str);
}
function printUsage(){
  console.log("USAGE: "+process.argv[0].split("/").slice(-1)[0]+" "+process.argv[1].split("/").slice(-1)[0]+" [MYSQL ROOT USER] [MYSQL ROOT PASSWORD] [OPTION 1] [OPTION 2] [...]\n("+process.argv[0]+" "+process.argv[1]+" [MYSQL ROOT USER] [MYSQL ROOT PASSWORD] [OPTION 1] [OPTION 2] [...])\n\nSYNOPSIS:\n\tInitialize mysql from config.js\n\nOPTIONS:\n"+
  "\nall:\n\tIntialize all\n\ntables:\n\tInitialize only tables (database has to exist)\n\nuser:\n\tCreate User\n\ndatabase:\n\tCreate database\n\ngrant:\n\tGrant rights to database (database and user have to exist)\n\nOptions can be in any creates, because they are createsed in the script");
  try{
    dbcon.end(process.exit);
  }catch(e){}

}
function handelResErr(res, err, message, funct){
  if(res){
    console.log(message);
  }
  if(err){
    if((err.code == "ER_DB_CREATE_EXISTS")||(err.code == "ER_TABLE_EXISTS_ERROR")||(err.code == "ER_CANNOT_USER")){
      existing[funct.toString().split("(")[0].split(" ")[1]]=funct;
      console.log("already exists");
    }else{
      console.error(err);;
    }
  }
}
